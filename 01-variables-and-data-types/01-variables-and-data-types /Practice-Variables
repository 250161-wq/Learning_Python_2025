#PEYMAN MIYANDASHTI 250161
# This script demonstrates the use of variables in Python.

# It includes examples of different data types and basic operations.

# Define variables of different data types

# First, we  have to know what is a variable

# A variable is a named location in memory that stores a value.

# Variables can hold different types of data, such as integers, floats, strings, and booleans,lists,tuples,dictionaries,sets,nonetypes,complex numbers, bytes, bytearrays, frozensets, ranges, memoryviews, custom classes/objects, functions, modules, files, generators, iterators, coroutines, context managers, enumerations, named tuples, data classes, frozen data classes,and more.

# Variables are created by assigning a value to a name using the assignment operator (=).
#So we are going to practice  All this variables in top of the code 1 by 1 , we are going to define them and print them out, then we are going to do some basic operations with them.
#so let's start with first Learn what is variable and what is the value of variable! , let's define some variable and assign some values to them.
#First we are going to work with strings (text) variables
#what is string variable?
#A string variable is a sequence of characters enclosed in single quotes (' ') or double quotes (" ").
#Strings can contain letters, numbers, symbols, and spaces.

name = "Peyman"# here we defined a variable called name and assigned it the value "Peyman", so we can say peyman is string variable and the strings always are in double quotes or single quotes, but i prefer double quotes. we can also call it text variable.and also i can use  str function to define a string variable like this:

greeting = str("Hello, World!")# here we defined a variable called greeting and assigned it the value "Hello, World!" using str function.Just  to remind you guys  when we use str function to define a string variable, we have to put the value inside the parentheses and also in double quotes or single quotes ! as you can see in the example above.

#Now we need to print them out ! probably you are going to ask what is print function? what it does? so let me explain it to you , print function is a built-in function in python that is used to print the specified message to the screen, or other standard output device. so let's print our string variables out:

print(name)# this will print the value of the variable name to the screen
print(greeting)# this will print the value of the variable greeting to the screen  
 
#So the output of the above code will be:

#Peyman
#Hello, World!
#Now that we have defined and printed out our string variables,

#we can practice it easily by changing the value of the string variables and printing them out again.

#For example:
name = "Arlette" # here we changed the value of the variable name to "Arlette"

#or we can also use str function to change the value of the string variable like this:

name = str("Arlette") # here we changed the value of the variable name to "Arlette" using str function

greeting = str("Good night Arlette!") # here we changed the value of the variable greeting to "Hi there!"

#Now let's print them out again to see the changes:

print(name) # this will print the new value of the variable name to the screen

print(greeting) # this will print the new value of the variable greeting to the screen

#So the output of the above code will be:

#Arlette
#Good night Arlette!

#Now let's move on to the next data type which is integer (whole numbers) variables,
 
#what is integer variable?
#An integer variable is a whole number without a decimal point. Integers can be positive, negative, or zero.

age = 25 # here we defined a variable called age and assigned it the value 25, so we can say 25 is integer variable.and also i can use  int function to define an integer variable like this:

height = int(175) # here we defined a variable called height and assigned it the value 175 using int function.Just  to remind you guys  when we use int function to define an integer variable, we have to put the value inside the parentheses without any quotes as you can see in the example above.

#Now we need to print them out ! so let's print our integer variables out:

print(age) # this will print the value of the variable age to the screen

print(height) # this will print the value of the variable height to the screen

#So the output of the above code will be:
#25
#175

#Now that we have defined and printed out our integer variables,

#we can practice it easily by changing the value of the integer variables and printing them out again.

age = 30 # here we changed the value of the variable age to 30

height = int(180) # here we changed the value of the variable height to 180 using int function

print(age) # this will print the new value of the variable age to the screen

print(height) # this will print the new value of the variable height to the screen

#So the output of the above code will be:
#30
#180
#Now let's move on to the next data type which is float (decimal numbers) variables,
#what is float variable?
#A float variable is a number that has a decimal point. Floats can be positive, negative, or zero.

weight = 70.5 # here we defined a variable called weight and assigned it the value 70.5, so we can say 70.5 is float variable.and also i can use  float function to define a float variable like this:

bmi = float(22.5) # here we defined a variable called bmi and assigned it the value 22.5 using float function.Just  to remind you guys  when we use float function to define a float variable, we have to put the value inside the parentheses without any quotes as you can see in the example above.

#Now we need to print them out ! so let's print our float variables out:

print(weight) # this will print the value of the variable weight to the screen

print(bmi) # this will print the value of the variable bmi to the screen

#So the output of the above code will be:
#70.5
#22.5

#Now that we have defined and printed out our float variables,
#we can practice it easily by changing the value of the float variables and printing them out again.

weight = 75.0 # here we changed the value of the variable weight to 75.0

bmi = float(23.0) # here we changed the value of the variable bmi to 23.0 using float function

print(weight) # this will print the new value of the variable weight to the screen

print(bmi) # this will print the new value of the variable bmi to the screen
#So the output of the above code will be:
#75.0
#23.0

#Now let's move on to the next data type which is boolean (True/False) variables,
#what is boolean variable?
#A boolean variable is a data type that can have one of two values: True or False.

is_student = True # here we defined a variable called is_student and assigned it the value True, so we can say True is boolean variable.and also i can use  bool function to define a boolean variable like this:

has_graduated = bool(False) # here we defined a variable called has_graduated and assigned it the value False using bool function.Just  to remind you guys  when we use bool function to define a boolean variable, we have to put the value inside the parentheses without any quotes as you can see in the example above.

#Now we need to print them out ! so let's print our boolean variables out:
print(is_student) # this will print the value of the variable is_student to the screen

print(has_graduated) # this will print the value of the variable has_graduated to the screen

#So the output of the above code will be:
#True
#False

#Now that we have defined and printed out our boolean variables,
#we can practice it easily by changing the value of the boolean variables and printing them out again.

is_student = False # here we changed the value of the variable is_student to False

has_graduated = bool(True) # here we changed the value of the variable has_graduated to True using bool function

print(is_student) # this will print the new value of the variable is_student to the screen

print(has_graduated) # this will print the new value of the variable has_graduated to the screen

#So the output of the above code will be:
#False
#True

#Now let's move on to the next data type which is list variables,
#what is list variable?
#A list variable is a collection of items that are ordered and changeable. Lists are defined by enclosing the items in square brackets [ ] and separating them with commas.

fruits = ["apple", "banana", "cherry"] # here we defined a variable called fruits and assigned it a list of fruit names, so we can say fruits is a list variable.and also i can use  list function to define a list variable like this:

vegetables = list(["carrot", "broccoli", "spinach"]) # here we defined a variable called vegetables and assigned it a list of vegetable names using list function.Just  to remind you guys  when we use list function to define a list variable, we have to put the items inside the parentheses and also in square brackets [ ] as you can see in the example above.

#Now we need to print them out ! so let's print our list variables out:

print(fruits) # this will print the value of the variable fruits to the screen

print(vegetables) # this will print the value of the variable vegetables to the screen

#So the output of the above code will be:
#['apple', 'banana', 'cherry']
#['carrot', 'broccoli', 'spinach']
#Now that we have defined and printed out our list variables,
#we can practice it easily by changing the value of the list variables and printing them out again.
fruits = ["orange", "grape", "kiwi"] # here we changed the value of the variable fruits to a new list of fruit names

vegetables = list(["potato", "cucumber", "lettuce"]) # here we changed the value of the variable vegetables to a new list of vegetable names using list function

print(fruits) # this will print the new value of the variable fruits to the screen

print(vegetables) # this will print the new value of the variable vegetables to the screen

#So the output of the above code will be:
#['orange', 'grape', 'kiwi']
#['potato', 'cucumber', 'lettuce']

#Now let's move on to the next data type which is tuple variables,
#what is tuple variable?
#A tuple variable is a collection of items that are ordered and unchangeable. Tuples are defined by enclosing the items in parentheses ( ) and separating them with commas.

colors = ("red", "green", "blue") # here we defined a variable called colors and assigned it a tuple of color names, so we can say colors is a tuple variable.and also i can use  tuple function to define a tuple variable like this:

shapes = tuple(("circle", "square", "triangle")) # here we defined a variable called shapes and assigned it a tuple of shape names using tuple function.Just  to remind you guys  when we use tuple function to define a tuple variable, we have to put the items inside the parentheses and also in parentheses ( ) as you can see in the example above.
#Now we need to print them out ! so let's print our tuple variables out:
print(colors) # this will print the value of the variable colors to the screen

print(shapes) # this will print the value of the variable shapes to the screen

#So the output of the above code will be:
#('red', 'green', 'blue')
#('circle', 'square', 'triangle')

#Now that we have defined and printed out our tuple variables,
#we can practice it easily by changing the value of the tuple variables and printing them out again.

colors = ("yellow", "purple", "orange") # here we changed the value of the variable colors to a new tuple of color names

shapes = tuple(("rectangle", "oval", "hexagon")) # here we changed the value of the variable shapes to a new tuple of shape names using tuple function

print(colors) # this will print the new value of the variable colors to the screen

print(shapes) # this will print the new value of the variable shapes to the screen

#So the output of the above code will be:
#('yellow', 'purple', 'orange')
#('rectangle', 'oval', 'hexagon')

#Now let's move on to the next data type which is dictionary variables,
#what is dictionary variable?
#A dictionary variable is a collection of key-value pairs that are unordered, changeable, and indexed. Dictionaries are defined by enclosing the items in curly braces { } and separating them with commas. Each key is separated from its value by a colon (:).

person = {"name": "Peyman", "age": 43, "city": "Tabriz"} # here we defined a variable called person and assigned it a dictionary of personal information, so we can say person is a dictionary variable.and also i can use  dict function to define a dictionary variable like this:

car = dict({"brand": "Kia", "model": "Sportage", "year": 2024}) # here we defined a variable called car and assigned it a dictionary of car information using dict function.Just  to remind you guys  when we use dict function to define a dictionary variable, we have to put the items inside the parentheses and also in curly braces { } as you can see in the example above.

#Now we need to print them out ! so let's print our dictionary variables out:

print(person) # this will print the value of the variable person to the screen

print(car) # this will print the value of the variable car to the screen

#So the output of the above code will be:
#{'name': 'Peyman', 'age': 43, 'city': 'Tabriz'}
#{'brand': 'Kia', 'model': 'Sportage', 'year': 2024}

#Now that we have defined and printed out our dictionary variables,

#we can practice it easily by changing the value of the dictionary variables and printing them out again.

person = {"name": "Arlette", "age": 47, "city": "Mexico"} # here we changed the value of the variable person to a new dictionary of personal information

car = dict({"brand": "Hyundai", "model": "Creta", "year": 2018}) # here we changed the value of the variable car to a new dictionary of car information using dict function 

print(person) # this will print the new value of the variable person to the screen

print(car) # this will print the new value of the variable car to the screen

#So the output of the above code will be:
#{'name': 'Arlette', 'age': 47, 'city': 'Mexico'}
#{'brand': 'Hyundai', 'model': 'Creta', 'year': 2018}

#Now let's move on to the next data type which is set variables,
#what is set variable?
#A set variable is a collection of unique items that are unordered and unindexed. Sets are defined by enclosing the items in curly braces { } and separating them with commas.

animals = {"dog", "cat", "bird"} # here we defined a variable called animals and assigned it a set of animal names, so we can say animals is a set variable.and also i can use  set function to define a set variable like this:

colors_set = set(["red", "green", "blue"]) # here we defined a variable called colors_set and assigned it a set of color names using set function.Just  to remind you guys  when we use set function to define a set variable, we have to put the items inside the parentheses and also in square brackets [ ] as you can see in the example above.

#Now we need to print them out ! so let's print our set variables out:
print(animals) # this will print the value of the variable animals to the screen

print(colors_set) # this will print the value of the variable colors_set to the screen

#So the output of the above code will be:
#{'dog', 'cat', 'bird'}
#{'red', 'green', 'blue'}
#Now that we have defined and printed out our set variables,

#we can practice it easily by changing the value of the set variables and printing them out again.

animals = {"lion", "tiger", "bear"} # here we changed the value of the variable animals to a new set of animal names

colors_set = set(["yellow", "purple", "orange"]) # here we changed the value of the variable colors_set to a new set of color names using set function

print(animals) # this will print the new value of the variable animals to the screen

print(colors_set) # this will print the new value of the variable colors_set to the screen

#So the output of the above code will be:
#{'lion', 'tiger', 'bear'}
#{'yellow', 'purple', 'orange'}

#Now let's move on to the next data type which is NoneType variable,
#what is NoneType variable?
#A NoneType variable is a special data type that represents the absence of a value or a null value. The only value of NoneType is None.

nothing = None # here we defined a variable called nothing and assigned it the value None, so we can say nothing is a NoneType variable.

#Why we need to use NoneType variable? And where we can use it?
#We can use NoneType variable when we want to indicate that a variable has no value or when we want to initialize a variable without assigning any value to it.

#Now we need to print it out ! so let's print our NoneType variable out:
print(nothing) # this will print the value of the variable nothing to the screen

#So the output of the above code will be:
#None
#Now that we have defined and printed out our NoneType variable,

#we can practice it easily by changing the value of the NoneType variable and printing it out again.

nothing = None # here we changed the value of the variable nothing to None again

print(nothing) # this will print the new value of the variable nothing to the screen

#So the output of the above code will be:
#None
#Now let's move on to the next data type which is complex number variable,
#what is complex number variable?
#A complex number variable is a number that has a real part and an imaginary part. Complex numbers are defined by using the letter j to represent the imaginary part.
#why we need to use complex number variable? And where we can use it?
#We can use complex number variable in mathematical calculations and scientific computations that involve complex numbers.

complex_num = 3 + 4j # here we defined a variable called complex_num and assigned it the value 3 + 4j, so we can say complex_num is a complex number variable.and also i can use  complex function to define a complex number variable like this:

another_complex_num = complex(5, 6) # here we defined a variable called another_complex_num and assigned it the value 5 + 6j using complex function.Just  to remind you guys  when we use complex function to define a complex number variable, we have to put the real part and imaginary part inside the parentheses without any quotes as you can see in the example above.
#Probably you are gloing to ask what is the j letter after number 4 ? letter j is used to represent the imaginary part of a complex number in Python. In mathematics, the imaginary unit is denoted by the letter i, but in Python, we use j to avoid confusion with the variable i that is commonly used in programming.

#Now we need to print them out ! so let's print our complex number variables out:

print(complex_num) # this will print the value of the variable complex_num to the screen

print(another_complex_num) # this will print the value of the variable another_complex_num to the screen

#So the output of the above code will be:
#(3+4j)
#(5+6j)
#Now that we have defined and printed out our complex number variables,

#we can practice it easily by changing the value of the complex number variables and printing them out again with something else.

complex_num = 7 + 8j # here we changed the value of the variable complex_num to 7 + 8j

print(complex_num) # this will print the new value of the variable complex_num to the screen

#So the output of the above code will be:
#(7+8j)

another_complex_num = complex(9, 10) # here we changed the value of the variable another_complex_num to 9 + 10j using complex function

print(another_complex_num) # this will print the new value of the variable another_complex_num to the screen

#So the output of the above code will be:
#(9+10j)
#Now let's move on to the next data type which is bytes variable,
#what is bytes variable? and what it does? 
#A bytes variable is a sequence of bytes that represents binary data. Bytes are defined by enclosing the byte values in single quotes (' ') or double quotes (" ") and prefixing them with the letter b.

data = b"Hello, World!" # here we defined a variable called data and assigned it the value b"Hello, World!", so we can say data is a bytes variable.and also i can use  bytes function to define a bytes variable like this:

more_data = bytes([72, 101, 108, 108, 111]) # here we defined a variable called more_data and assigned it the byte values using bytes function.Just  to remind you guys  when we use bytes function to define a bytes variable, we have to put the byte values inside the parentheses and also in square brackets [ ] as you can see in the example above.

#Now we need to print them out ! so let's print our bytes variables out:

print(data) # this will print the value of the variable data to the screen

print(more_data) # this will print the value of the variable more_data to the screen

#So the output of the above code will be:
#b'Hello, World!'
#b'Hello'

#Now that we have defined and printed out our bytes variables,
#we can practice it easily by changing the value of the bytes variables and printing them out again.

data = b"Goodbye, World!" # here we changed the value of the variable data to b"Goodbye, World!"

print(data) # this will print the new value of the variable data to the screen

#So the output of the above code will be:
#b'Goodbye, World!'

more_data = bytes([87, 111, 114, 108, 100]) # here we changed the value of the variable more_data to the byte values using bytes function

print(more_data) # this will print the new value of the variable more_data to the screen

#So the output of the above code will be:
#b'World'
#Probably you are going to ask what is the difference between string variable and bytes variable? so let me explain it to you , the main difference between string variable and bytes variable is that string variable is used to represent text data, while bytes variable is used to represent binary data. String variables are human-readable and can be easily manipulated using string methods, while bytes variables are not human-readable and require special handling for manipulation.

#Now let's move on to the next data type which is bytearray variable,
#what is bytearray variable? and what it does?
#A bytearray variable is a mutable sequence of bytes that represents binary data. Bytearrays are defined by using the bytearray() function.

mutable_data = bytearray(b"Hello, World!") # here we defined a variable called mutable_data and assigned it the value b"Hello, World!", so we can say mutable_data is a bytearray variable.and also i can use  bytearray function to define a bytearray variable like this:

more_mutable_data = bytearray([72, 101, 108, 108, 111]) # here we defined a variable called more_mutable_data and assigned it the byte values using bytearray function.Just  to remind you guys  when we use bytearray function to define a bytearray variable, we have to put the byte values inside the parentheses and also in square brackets [ ] as you can see in the example above.

#Now we need to print them out ! so let's print our bytearray variables out:

print(mutable_data) # this will print the value of the variable mutable_data to the screen

print(more_mutable_data) # this will print the value of the variable more_mutable_data to the screen

#So the output of the above code will be:
#bytearray(b'Hello, World!')
#bytearray(b'Hello')

#Now that we have defined and printed out our bytearray variables,

#we can practice it easily by changing the value of the bytearray variables and printing them out again.

mutable_data = bytearray(b"Goodbye, World!") # here we changed the value of the variable mutable_data to b"Goodbye, World!"

print(mutable_data) # this will print the new value of the variable mutable_data to the screen

#So the output of the above code will be:
#bytearray(b'Goodbye, World!')

more_mutable_data = bytearray([87, 111, 114, 108, 100]) # here we changed the value of the variable more_mutable_data to the byte values using bytearray function

print(more_mutable_data) # this will print the new value of the variable more_mutable_data to the screen

#So the output of the above code will be:
#bytearray(b'World')
#Probably you are going to ask what is the difference between bytes variable and bytearray variable? so let me explain it to you , the main difference between bytes variable and bytearray variable is that bytes variable is immutable, meaning that its value cannot be changed after it is created, while bytearray variable is mutable, meaning that its value can be changed after it is created. Bytes variables are used when you need to work with binary data that should not be modified, while bytearray variables are used when you need to work with binary data that may need to be modified.
#Now let's move on to the next data type which is frozenset variable,
#what is frozenset variable? and what it does?
#A frozenset variable is an immutable collection of unique items that are unordered and unindexed. Frozensets are defined by using the frozenset() function.

immutable_animals = frozenset(["dog", "cat", "bird"]) # here we defined a variable called immutable_animals and assigned it a frozenset of animal names, so we can say immutable_animals is a frozenset variable.and also i can use  frozenset function to define a frozenset variable like this:

more_immutable_animals = frozenset(("lion", "tiger", "bear")) # here we defined a variable called more_immutable_animals and assigned it a frozenset of animal names using frozenset function.Just  to remind you guys  when we use frozenset function to define a frozenset variable, we have to put the items inside the parentheses and also in parentheses ( ) as you can see in the example above.

#Now we need to print them out ! so let's print our frozenset variables out:

print(immutable_animals) # this will print the value of the variable immutable_animals to the screen

print(more_immutable_animals) # this will print the value of the variable more_immutable_animals to the screen

#So the output of the above code will be:
#{'dog', 'cat', 'bird'}
#{'lion', 'tiger', 'bear'}

#Now that we have defined and printed out our frozenset variables,

#we can practice it easily by changing the value of the frozenset variables and printing them out again.

immutable_animals = frozenset(["elephant", "giraffe", "zebra"]) # here we changed the value of the variable immutable_animals to a new frozenset of animal names

print(immutable_animals) # this will print the new value of the variable immutable_animals to the screen

#So the output of the above code will be:
#{'elephant', 'giraffe', 'zebra'}

more_immutable_animals = frozenset(("wolf", "fox", "bear")) # here we changed the value of the variable more_immutable_animals to a new frozenset of animal names using frozenset function

print(more_immutable_animals) # this will print the new value of the variable more_immutable_animals to the screen

#So the output of the above code will be:
#{'wolf', 'fox', 'bear'}
#Probably you are going to ask what is the difference between set variable and frozenset variable? so let me explain it to you , the main difference between set variable and frozenset variable is that set variable is mutable, meaning that its value can be changed after it is created, while frozenset variable is immutable, meaning that its value cannot be changed after it is created. Set variables are used when you need to work with a collection of unique items that may need to be modified, while frozenset variables are used when you need to work with a collection of unique items that should not be modified.

#Now let's move on to the next data type which is range variable,
#what is range variable? and what it does?
#A range variable is a sequence of numbers that are generated within a specified range. Ranges are defined by using the range() function.

numbers = range(1, 10) # here we defined a variable called numbers and assigned it a range of numbers from 1 to 9, so we can say numbers is a range variable.and also i can use  range function to define a range variable like this:

more_numbers = range(5) # here we defined a variable called more_numbers and assigned it a range of numbers from 0 to 4 using range function.Just  to remind you guys  when we use range function to define a range variable, we have to put the start and end values inside the parentheses without any quotes as you can see in the example above.

#Now we need to print them out ! so let's print our range variables out:

print(list(numbers)) # this will print the value of the variable numbers to the screen

print(list(more_numbers)) # this will print the value of the variable more_numbers to the screen

#So the output of the above code will be:
#[1, 2, 3, 4, 5, 6, 7, 8, 9]
#[0, 1, 2, 3, 4]

#Now that we have defined and printed out our range variables,

#we can practice it easily by changing the value of the range variables and printing them out again.

numbers = range(10, 20) # here we changed the value of the variable numbers to a range of numbers from 10 to 19

print(list(numbers)) # this will print the new value of the variable numbers to the screen

#So the output of the above code will be:
#[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

more_numbers = range(3, 8) # here we changed the value of the variable more_numbers to a range of numbers from 3 to 7

print(list(more_numbers)) # this will print the new value of the variable more_numbers to the screen

#So the output of the above code will be:
#[3, 4, 5, 6, 7]

#Probably you are going to ask what is the difference between list variable and range variable? so let me explain it to you , the main difference between list variable and range variable is that list variable is a collection of items that can be of any data type, while range variable is a sequence of numbers that are generated within a specified range. List variables are used when you need to work with a collection of items that may need to be modified, while range variables are used when you need to work with a sequence of numbers for iteration or looping.

#Smething important  about range ! we have to know in python range function is exclusive of the end value, meaning that the end value is not included in the range. For example, range(1, 10) will generate numbers from 1 to 9, but not including 10. If you want to include the end value in the range, you can simply add 1 to the end value like this: range(1, 11) will generate numbers from 1 to 10, including 10. So that means we count numbers  in python from 0 to n-1  when we use range function. so number 0 is first number starting and when we want to reach to number n we have to write n+1 in range function. for example if we want to reach to number 10 we have to write range(0,11) because 11-1=10 . just to remind you guys when we use range function we have to put the start and end values inside the parentheses without any quotes as you can see in the example above.

# so lets do another example to make it more clear for you guys :
counting = range(0, 6) # here we defined a variable called counting and assigned it a range of numbers from 0 to 5

print(list(counting)) # this will print the value of the variable counting to the screen

#So the output of the above code will be:
#[0, 1, 2, 3, 4, 5]
#As you can see in the example above the end value 6 is not included in the range, so the output is from 0 to 5. If we want to include the end value 6 in the range, we have to write range(0, 7) like this:

counting = range(0, 7) # here we defined a variable called counting and assigned it a range of numbers from 0 to 6

print(list(counting)) # this will print the value of the variable counting to the screen

#So the output of the above code will be:
#[0, 1, 2, 3, 4, 5, 6]
#As you can see in the example above the end value 7 is not included in the range, so the output is from 0 to 6.
#Now let's move on to the next data type which is memoryview variable,
#what is memoryview variable? and what it does?
#A memoryview variable is a view object that allows you to access the memory of another binary data type without copying it. Memoryviews are defined by using the memoryview() function.

binary_data = bytearray(b"Hello, World!") # here we defined a variable called binary_data and assigned it the value b"Hello, World!"

memory_view = memoryview(binary_data) # here we defined a variable called memory_view and assigned it a memoryview of the binary_data variable

print(memory_view) # this will print the value of the variable memory_view to the screen

#So the output of the above code will be:
#<memory at 0x7f8b8c0d4d60>

#Now that we have defined and printed out our memoryview variable,

#we can practice it easily by changing the value of the memoryview variable and printing it out again.

binary_data = bytearray(b"Goodbye, World!") # here we changed the value of the variable binary_data to b"Goodbye, World!"

memory_view = memoryview(binary_data) # here we changed the value of the variable memory_view to a memoryview of the binary_data variable

print(memory_view) # this will print the new value of the variable memory_view to the screen

#So the output of the above code will be:
#<memory at 0x7f8b8c0d4d60>
#Probably you are going to ask what is the difference between bytes variable and memoryview variable? so let me explain it to you , the main difference between bytes variable and memoryview variable is that bytes variable is a sequence of bytes that represents binary data, while memoryview variable is a view object that allows you to access the memory of another binary data type without copying it. Bytes variables are used when you need to work with binary data that should not be modified, while memoryview variables are used when you need to work with binary data that may need to be modified without creating a copy of it.

#Now let's move on to the next data type which is Custom classes/objects,

#what is Custom classes/objects? and what it does?
#A custom class is a user-defined data type that allows you to create your own objects with specific attributes and methods. Classes are defined using the class keyword followed by the class name and a colon.
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, my name is {self.name} and I am {self.age} years old."
# here we defined a custom class called Person with attributes name and age, and a method greet.

person1 = Person("Peyman", 43) # here we created an object of the Person class called person1

print(person1.greet()) # this will print the result of the greet method of the person1 object to the screen

#So the output of the above code will be:
#Hello, my name is Peyman and I am 43 years old.
#Now that we have defined and printed out our custom class/object,
#we can practice it easily by changing the attributes of the custom class/object and printing it out again.

person1.name = "Arlette" # here we changed the name attribute of the person1 object to "Arlette"

person1.age = 47 # here we changed the age attribute of the person1 object to 47

print(person1.greet()) # this will print the result of the greet method of the person1 object to the screen

#So the output of the above code will be:
#Hello, my name is Arlette and I am 47 years old.

#Probably you are going to ask what is the difference between built-in data types and custom classes/objects? so let me explain it to you , the main difference between built-in data types and custom classes/objects is that built-in data types are predefined data types that are provided by Python, while custom classes/objects are user-defined data types that allow you to create your own objects with specific attributes and methods. Built-in data types are used for basic data manipulation and storage, while custom classes/objects are used for more complex data structures and behaviors.
#Example of an built-in data type:
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    def bark(self):
        return f"{self.name} says Woof!"
dog1 = Dog("Buddy", "Golden Retriever") # here we created an object of the Dog class called dog1

print(dog1.bark()) # this will print the result of the bark method of the dog1 object to the screen
#So the output of the above code will be:
#Buddy says Woof!
#This is an example of a built-in data type because the Dog class is a predefined data type that is provided by Python.

#Example of another custom class/object:
class Car:
    def __init__(self, brand, model, year):
        self.brand = brand
        self.model = model
        self.year = year

    def info(self):
        return f"This car is a {self.year} {self.brand} {self.model}."
car1 = Car("Kia", "Sportage", 2024) # here we created an object of the Car class called car1
print(car1.info()) # this will print the result of the info method of the car1 object to the screen

#So the output of the above code will be:
#This car is a 2024 Kia Sportage.
#Now that we have defined and printed out our custom class/object,

#we can practice it easily by changing the attributes of the custom class/object and printing it out again.

car1.brand = "Hyundai" # here we changed the brand attribute of the car1 object to "Hyundai"

car1.model = "Creta" # here we changed the model attribute of the car1 object to "Creta"

car1.year = 2018 # here we changed the year attribute of the car1 object to 2018

print(car1.info()) # this will print the result of the info method of the car1 object to the screen

#So the output of the above code will be:
#This car is a 2018 Hyundai Creta.
#Probably you are going to ask what is the difference between functions and custom classes/objects? so let me explain it to you , the main difference between functions and custom classes/objects is that functions are reusable blocks of code that perform a specific task, while custom classes/objects are user-defined data types that allow you to create your own objects with specific attributes and methods. Functions are used for procedural programming, while custom classes/objects are used for object-oriented programming.
#Now let's move on to the next data type which is functions,
#what is functions? and what it does?

#A function is a reusable block of code that performs a specific task. Functions are defined using the def keyword followed by the function name and parentheses.

def greet(name):
    return f"Hello, {name}!"

# here we defined a function called greet that takes a parameter name and returns a greeting message.

print(greet("Peyman")) # this will print the result of the greet function to the screen

#So the output of the above code will be:
#Hello, Peyman!

#Now that we have defined and printed out our function,

#we can practice it easily by changing the parameter of the function and printing it out again.

print(greet("Arlette")) # this will print the result of the greet function to the screen

#So the output of the above code will be:

#Hello, Arlette!

#Probably you are going to ask what is the difference between functions and methods? so let me explain it to you , the main difference between functions and methods is that functions are standalone blocks of code that can be called independently, while methods are functions that are associated with an object and can only be called on that object. Functions are defined using the def keyword, while methods are defined within a class using the def keyword. Functions are used for procedural programming, while methods are used for object-oriented programming.

#Example of a function:
def add(a, b):
    return a + b
print(add(5, 10)) # this will print the result of the add function to the screen
#So the output of the above code will be:
#15
#This is an example of a function because the add function is a standalone block of code that can be called independently.
#Example of a method:

class Calculator:
    def add(self, a, b):
        return a + b
calc = Calculator() # here we created an object of the Calculator class called calc

print(calc.add(5, 10)) # this will print the result of the add method of the calc object to the screen

#So the output of the above code will be:
#15
#This is an example of a method because the add method is associated with the Calculator object and can only be called on that object.

#Now let's move on to the next data type which is moudules,
#what is moudules? and what it does?
#A module is a file that contains Python code that can be imported and used in other Python programs. Modules are defined by creating a new Python file with a .py extension.

#Here is an example of how to create and use a module:

#First, we need to create a new Python file called my_module.py and define a function inside it:
def greet(name):
    return f"Hello, {name}!"
#Now we can import the my_module module in another Python file and use the greet function:
import my_module
print(my_module.greet("Peyman")) # this will print the result of the greet function from the my_module module to the screen
#So the output of the above code will be:
#Hello, Peyman!
#Now that we have defined and printed out our module,
#we can practice it easily by changing the parameter of the function in the module and printing it out again.
print(my_module.greet("Arlette")) # this will print the result of the greet function

#So the output of the above code will be:
#Hello, Arlette!
#from the my_module module to the screen
#Probably you are going to ask what is the difference between modules and packages? so let me explain it to you , the main difference between modules and packages is that modules are single files that contain Python code, while packages are collections of modules that are organized in a directory hierarchy. Modules are used for organizing code into reusable components, while packages are used for organizing related modules into a single namespace.
#Example of a module:
#my_module.py
def add(a, b):
    return a + b
#Now we can import the my_module module in another Python file and use the add function:
import my_module
print(my_module.add(5, 10)) # this will print the result of the add function from the my_module module to the screen
#So the output of the above code will be:
#15
#This is an example of a module because the my_module.py file is a single file that contains Python code.
#Example of a package:
#my_package/__init__.py
#my_package/math_operations.py
def add(a, b):
    return a + b
def subtract(a, b):
    return a - b
#Now we can import the my_package package in another Python file and use the add and subtract functions:
from my_package import math_operations
print(math_operations.add(5, 10)) # this will print the result of the add function from the math_operations module to the screen
print(math_operations.subtract(10, 5)) # this will print the result of the subtract
#So the output of the above code will be:
#15
#5
#This is an example of a package because the my_package directory contains multiple modules that are organized in a directory hierarchy.

#Now let's move on to the next data type which is files ,
#what is files? and what it does?
#A file is a collection of data that is stored on a computer or other storage device. Files can be created, read, written, and deleted using Python's built-in file handling functions.
#Here is an example of how to create, write, read, and delete a file in Python:
#Creating and writing to a file
with open("example.txt", "w") as file:
    file.write("Hello, World!")
# here we created a new file called example.txt and wrote the text "Hello, World!" to it
#Reading from a file
with open("example.txt", "r") as file:
    content = file.read()
    print(content) # this will print the content of the example.txt file to the screen
#So the output of the above code will be:
#Hello, World!
#Deleting a file
import os
os.remove("example.txt") # here we deleted the example.txt file
#Now that we have created, written, read, and deleted a file,
#we can practice it easily by creating, writing, reading, and deleting another file.
#Creating and writing to a file
with open("sample.txt", "w") as file:
    file.write("Python is awesome!")
# here we created a new file called sample.txt and wrote the text "Python is awesome!" to it
#Reading from a file
with open("sample.txt", "r") as file:
    content = file.read()
    print(content) # this will print the content of the sample.txt file to the screen
#So the output of the above code will be:
#Python is awesome!
#Deleting a file
import os
os.remove("sample.txt") # here we deleted the sample.txt file
#Probably you are going to ask what is the difference between text files and binary files? so let me explain it to you , the main difference between text files and binary files is that text files are files that contain human-readable characters, while binary files are files that contain non-human-readable data. Text files are used for storing and exchanging text-based data, while binary files are used for storing and exchanging non-text-based data such as images, audio, and video.
#Example of a text file:
with open("text_file.txt", "w") as file:
    file.write("This is a text file.")
with open("text_file.txt", "r") as file:
    content = file.read()
    print(content) # this will print the content of the text_file.txt file to the screen
#So the output of the above code will be:
#This is a text file.
#This is an example of a text file because the text_file.txt file contains human-readable characters.
#Example of a binary file:
with open("binary_file.bin", "wb") as file:
    file.write(b"\x00\x01\x02\x03\x04")
with open("binary_file.bin", "rb") as file:
    content = file.read()
    print(content) # this will print the content of the binary_file.bin file to the screen
#So the output of the above code will be:
#b'\x00\x01\x02\x03\x04'
#This is an example of a binary file because the binary_file.bin file contains non-human-readable data.

#Now let's move on to the next data type which is generators,
#what is generators? and what it does?
#A generator is a special type of iterator that allows you to generate a sequence of values on
#the fly, without having to store them all in memory at once. Generators are defined using the yield keyword inside a function.
def countdown(n):
    while n > 0:
        yield n
        n -= 1
# here we defined a generator function called countdown that takes a parameter n and yields
#the values from n down to 1.
for number in countdown(5):
    print(number) # this will print the values generated by the countdown generator to the screen
#So the output of the above code will be:
#5
#4
#3
#2
#1
#Now that we have defined and printed out our generator,
#we can practice it easily by changing the parameter of the generator and printing it out again.
for number in countdown(3):
    print(number) # this will print the values generated by the countdown generator to the screen
#So the output of the above code will be:
#3
#2
#1
#Probably you are going to ask what is the difference between generators and lists? so let me explain it to you , the main difference between generators and lists is that generators generate values on the fly, while lists store all values in memory at once. Generators are more memory-efficient than lists, especially when dealing with large datasets, because they only generate values as needed. Lists, on the other hand, can be more convenient for certain operations that require random access to elements.
#Example of a generator:
def even_numbers(n):
    for i in range(n):
        if i % 2 == 0:
            yield i
for number in even_numbers(10):
    print(number) # this will print the even numbers generated by the even_numbers generator to the screen  
#So the output of the above code will be:
#0
#2
#4
#6
#8
#This is an example of a generator because the even_numbers function generates even numbers on the fly using the yield keyword.
#Example of a list:
even_numbers_list = [i for i in range(10) if i % 2 == 0]
for number in even_numbers_list:
    print(number) # this will print the even numbers stored in the even_numbers_list to the screen
#So the output of the above code will be:
#0
#2
#4
#6
#8  
#This is an example of a list because the even_numbers_list variable stores all even numbers in memory at once using a list comprehension.
#Now that we have practiced different types of variables in Python, you can try to create yours

#Now let's move on to the next data type which is iterators,
#what is iterators? and what it does?
#An iterator is an object that allows you to traverse through a collection of items, such as a list or a tuple, one item at a time. Iterators are defined by implementing the __iter__() and __next__() methods.
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index < len(self.data):
            result = self.data[self.index]
            self.index += 1
            return result
        else:
            raise StopIteration
# here we defined a custom iterator class called MyIterator that takes a collection of data and allows you to iterate through it.

my_list = [1, 2, 3, 4, 5]
my_iterator = MyIterator(my_list) # here we created an object of the MyIterator class called my_iterator
for item in my_iterator:
    print(item) # this will print the items generated by the my_iterator to the screen
#So the output of the above code will be:
#1
#2
#3
#4
#5
#Now that we have defined and printed out our iterator,
#we can practice it easily by changing the collection of data in the iterator and printing it out
my_list = ['a', 'b', 'c']
my_iterator = MyIterator(my_list) # here we created an object of the MyIterator class called my_iterator
for item in my_iterator:
    print(item) # this will print the items generated by the my_iterator to the screen
    
#So the output of the above code will be:
#a
#b
#c
#Probably you are going to ask what is the difference between iterators and generators? so let me explain it to you , the main difference between iterators and generators is that iterators are objects that implement the __iter__() and __next__() methods, while generators are functions that use the yield keyword to generate values on the fly. Iterators can be more complex to implement than generators, but they can also provide more control over the iteration process. Generators, on the other hand, are simpler to implement and can be more memory-efficient than iterators.
#Example of an iterator:
class CountUpTo:
    def __init__(self, max):
        self.max = max
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current < self.max:
            self.current += 1
            return self.current
        else:
            raise StopIteration
        
count_up_to_5 = CountUpTo(5)
for number in count_up_to_5:
    
    print(number) # this will print the numbers generated by the count_up_to_5 iterator to the screen
    
#So the output of the above code will be:
#1
#2
#3
#4
#5
#This is an example of an iterator because the CountUpTo class implements the __iter__() and __next__() methods to allow iteration through a sequence of numbers.
#Example of a generator:
def count_up_to(max):
    current = 0
    while current < max:
        current += 1
        yield current
for number in count_up_to(5):
    print(number) # this will print the numbers generated by the count_up_to generator to the screen
#So the output of the above code will be:
#1
#2
#3
#4
#5
#This is an example of a generator because the count_up_to function uses the yield keyword to generate a sequence of numbers on the fly.

#Now let's move on to the next data type which is coroutines,
#what is coroutines? and what it does?
#A coroutine is a special type of function that allows you to pause and resume its execution at specific points, enabling cooperative multitasking. Coroutines are defined using the async def syntax and can be paused using the await keyword.
import asyncio  
async def my_coroutine():
    print("Coroutine started")
    await asyncio.sleep(1)
    print("Coroutine resumed after 1 second")
# here we defined a coroutine function called my_coroutine that prints a message, pauses for 1 second, and then prints another message.

asyncio.run(my_coroutine()) # this will run the my_coroutine coroutine
#So the output of the above code will be:
#Coroutine started
#Coroutine resumed after 1 second
#Now that we have defined and printed out our coroutine,
#we can practice it easily by changing the pause duration in the coroutine and printing it out again.
async def my_coroutine():
    print("Coroutine started")
    await asyncio.sleep(2)
    print("Coroutine resumed after 2 seconds")
asyncio.run(my_coroutine()) # this will run the my_coroutine coroutine
#So the output of the above code will be:
#Coroutine started
#Coroutine resumed after 2 seconds
#Probably you are going to ask what is the difference between coroutines and threads? so let me explain it to you , the main difference between coroutines and threads is that coroutines are cooperative, meaning that they voluntarily yield control to other coroutines, while threads are preemptive, meaning that the operating system can interrupt a thread at any time to switch to another thread. Coroutines are more lightweight than threads, as they do not require the overhead of context switching and can be more efficient for I/O-bound tasks. Threads, on the other hand, can be more suitable for CPU-bound tasks that require parallel execution.
#Example of a coroutine:
import asyncio
async def fetch_data():
    print("Fetching data...")
    await asyncio.sleep(1)
    print("Data fetched!")
    
asyncio.run(fetch_data()) # this will run the fetch_data coroutine
#So the output of the above code will be:
#Fetching data...
#Data fetched!

#This is an example of a coroutine because the fetch_data function uses the async def syntax and the await keyword to pause and resume its execution.
#Example of a thread:
import threading
import time
def fetch_data():
    print("Fetching data...")
    time.sleep(1)
    print("Data fetched!")
thread = threading.Thread(target=fetch_data)
thread.start() # this will start the fetch_data thread
thread.join() # this will wait for the fetch_data thread to finish
#So the output of the above code will be:
#Fetching data...
#Data fetched!
#This is an example of a thread because the fetch_data function is executed in a separate thread using the threading module.

#Now let's move on to the next data type which is context managers,
#what is context managers? and what it does?
#A context manager is a special type of object that defines a runtime context for a block of code, allowing you to set up and tear down resources automatically. Context managers are defined using the with statement and implement the __enter__() and __exit__() methods.
class MyContextManager:
    def __enter__(self):
        print("Entering the context")
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        print("Exiting the context")
# here we defined a custom context manager class called MyContextManager that prints messages when entering and exiting the context.
with MyContextManager() as cm:
    print("Inside the context")
# this will create a context using the MyContextManager and print messages to the screen
#So the output of the above code will be:
#Entering the context
#Inside the context
#Exiting the context
#Now that we have defined and printed out our context manager,
#we can practice it easily by changing the code inside the context and printing it out again.
with MyContextManager() as cm:
    print("Doing some work inside the context")
# this will create a context using the MyContextManager and print messages to the screen
#So the output of the above code will be:
#Entering the context
#Doing some work inside the context
#Exiting the context
#Probably you are going to ask what is the difference between context managers and try-finally blocks? so let me explain it to you , the main difference between context managers and try-finally blocks is that context managers provide a more concise and readable way to manage resources, while try-finally blocks require more boilerplate code. Context managers automatically handle the setup and teardown of resources, while try-finally blocks require you to manually write the code for resource management. Context managers also provide better error handling, as they can handle exceptions that occur within the context block.
#Example of a context manager:
class FileContextManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        if self.file:
            self.file.close()
with FileContextManager("example.txt", "w") as file:
    file.write("Hello, World!")
# this will create a context using the FileContextManager to write to a file
with open("example.txt", "r") as file:
    content = file.read()
    print(content) # this will print the content of the example.txt file to the screen
#So the output of the above code will be:
#Hello, World!
#This is an example of a context manager because the FileContextManager class implements the __enter
#() and __exit__() methods to manage the file resource.
#Example of a try-finally block:
file = open("example.txt", "w")
try:
    file.write("Hello, World!")
finally:
    file.close()
with open("example.txt", "r") as file:
    content = file.read()
    print(content) # this will print the content of the example.txt file to the screen
#So the output of the above code will be:
#Hello, World!
#This is an example of a try-finally block because the file resource is managed manually using the try and finally keywords.

#Now let's move on to the next data type which is enumerators,
#what is enumerators? and what it does?
#An enumerator is an object that allows you to iterate through a collection of items while keeping track of the index of each item. Enumerators are defined using the built-in enumerate() function.
my_list = ['apple', 'banana', 'cherry']
for index, item in enumerate(my_list):
    print(f"Index: {index}, Item: {item}") # this will print the index and item of each element in the my_list to the screen
#So the output of the above code will be:
#Index: 0, Item: apple
#Index: 1, Item: banana
#Index: 2, Item: cherry
#Now that we have defined and printed out our enumerator,
#we can practice it easily by changing the collection of data in the enumerator and printing it out again.
my_list = ['dog', 'cat', 'rabbit']
for index, item in enumerate(my_list):
    print(f"Index: {index}, Item: {item}") # this will print the index and item of each element in the my_list to the screen
#So the output of the above code will be:
#Index: 0, Item: dog
#Index: 1, Item: cat
#Index: 2, Item: rabbit
#Probably you are going to ask what is the difference between enumerators and iterators? so let me explain it to you , the main difference between enumerators and iterators is that enumerators provide both the index and the item of each element in a collection, while iterators only provide the item itself. Enumerators are useful when you need to keep track of the index of each item while iterating through a collection, while iterators are more general-purpose and can be used for any type of iteration.
#Example of an enumerator:
my_tuple = ('red', 'green', 'blue')
for index, color in enumerate(my_tuple):
    print(f"Index: {index}, Color: {color}") # this will print the index and color of each element in the my_tuple to the screen
#So the output of the above code will be:
#Index: 0, Color: red
#Index: 1, Color: green
#Index: 2, Color: blue
#This is an example of an enumerator because the enumerate() function provides both the index and the item of each element in the my_tuple.
#Example of an iterator:
my_tuple = ('red', 'green', 'blue')
my_iterator = iter(my_tuple)
for color in my_iterator:
    print(f"Color: {color}") # this will print the color of each element in the my_tuple to the screen
#So the output of the above code will be:
#Color: red
#Color: green
#Color: blue
#This is an example of an iterator because the iter() function creates an iterator object that allows you to iterate through the my_tuple without providing the index of each item.

#Now let's move on to the next data type which is named tuples,
#what is named tuples? and what it does?
#A named tuple is a subclass of the built-in tuple data type that allows you to define a tuple with named fields, making it easier to access and manipulate the data. Named tuples are defined using the collections.namedtuple() function.
from collections import namedtuple
Person = namedtuple('Person', ['name', 'age', 'city'])
person1 = Person(name='Peyman', age=43, city='Tabriz')

print(person1.name) # this will print the name field of the person1 named tuple to the screen
print(person1.age)  # this will print the age field of the person1 named tuple to the screen
print(person1.city) # this will print the city field of the person1 named tuple to the screen
#So the output of the above code will be:   
#Peyman
#43
#Tabriz
#Now that we have defined and printed out our named tuple,
#we can practice it easily by changing the fields of the named tuple and printing it out again.
person1 = Person(name='Arlette', age=47, city='Mexico City')
print(person1.name) # this will print the name field of the person1 named tuple to the screen
print(person1.age)  # this will print the age field of the person1 named tuple to the screen
print(person1.city) # this will print the city field of the person1 named tuple to the screen
#So the output of the above code will be:
#Arlette
#47
#Mexico City

#Probably you are going to ask what is the difference between named tuples and regular tuples? so let me explain it to you , the main difference between named tuples and regular tuples is that named tuples allow you to access the fields of the tuple using named attributes, while regular tuples only allow you to access the elements using index positions. Named tuples provide better readability and maintainability of code, as they make it clear what each field represents. Regular tuples, on the other hand, can be more concise and efficient for simple data structures.
#Example of a named tuple:
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
point1 = Point(x=10, y=20)
print(point1.x) # this will print the x field of the point1 named tuple to the screen
print(point1.y) # this will print the y field of the point1 named tuple to the screen
#So the output of the above code will be:
#10
#20
#This is an example of a named tuple because the Point named tuple allows you to access the x and y fields using named attributes.
#Example of a regular tuple:
point1 = (10, 20)
print(point1[0]) # this will print the first element of the point1 tuple to the screen
print(point1[1]) # this will print the second element of the point1 tuple to the screen
#So the output of the above code will be:
#10
#20 
#This is an example of a regular tuple because the point1 tuple only allows you to access the elements using index positions.
#Now let's move on to the next data type which is data classes,
#what is data classes? and what it does?
#A data class is a special type of class that is designed to hold data, providing a simple and concise way to define classes with attributes. Data classes are defined using the @dataclass decorator from the dataclasses module.
from dataclasses import dataclass
@dataclass
class Person:
    name: str
    age: int
    city: str   
person1 = Person(name='Peyman', age=43, city='Tabriz')  
print(person1.name) # this will print the name attribute of the person1 data class to the screen
print(person1.age)  # this will print the age attribute of the person1 data class to the screen
print(person1.city) # this will print the city attribute of the person1 data class to the screen
#So the output of the above code will be:
#Peyman
#43
#Tabriz
#Now that we have defined and printed out our data class,
#we can practice it easily by changing the attributes of the data class and printing it out again
person1 = Person(name='Arlette', age=47, city='Mexico City')
print(person1.name) # this will print the name attribute of the person1 data class to
print(person1.age)  # this will print the age attribute of the person1 data class to the screen
print(person1.city) # this will print the city attribute of the person1 data class to the screen
#So the output of the above code will be:
#Arlette
#47
#Mexico City

#Probably you are going to ask what is the difference between data classes and regular classes? so let me explain it to you , the main difference between data classes and regular classes is that data classes provide a more concise and readable way to define classes with attributes, while regular classes require more boilerplate code. Data classes automatically generate special methods such as __init__(), __repr__(), and __eq__() based on the defined attributes, while regular classes require you to manually define these methods. Data classes are more suitable for simple data structures, while regular classes are more flexible and can be used for complex behaviors.
#Example of a data class:
from dataclasses import dataclass
@dataclass
class Point:
    x: int
    y: int
point1 = Point(x=10, y=20)
print(point1.x) # this will print the x attribute of the point1 data class to the screen
print(point1.y) # this will print the y attribute of the point1 data class to the screen
#So the output of the above code will be:
#10
#20
#This is an example of a data class because the Point data class automatically generates special methods based on the defined attributes.
#Example of a regular class:
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
point1 = Point(x=10, y=20)
print(point1.x) # this will print the x attribute of the point1 regular class to the screen
print(point1.y) # this will print the y attribute of the point1 regular class to the screen
#So the output of the above code will be:
#10
#20 
#This is an example of a regular class because the Point class requires you to manually define the __init__() method to initialize the attributes.

# Now let's move on to the next data type which is frozen data classes,
# what is frozen data classes? and what it does?
# A frozen data class is a special type of data class that is immutable, meaning that its attributes cannot be changed after the object is created. Frozen data classes are defined using the @dataclass decorator with the frozen=True parameter from the dataclasses module.
from dataclasses import dataclass
@dataclass(frozen=True)
class Person:
    name: str
    age: int
    city: str
person1 = Person(name='Peyman', age=43, city='Tabriz')  
print(person1.name) # this will print the name attribute of the person1 frozen data class to the screen
print(person1.age)  # this will print the age attribute of the person1 frozen data class to the screen
print(person1.city) # this will print the city attribute of the person1 frozen data class to the screen
#So the output of the above code will be:
#Peyman
#43
#Tabriz 
#Now that we have defined and printed out our frozen data class,
#we can practice it easily by trying to change the attributes of the frozen data class and see what happens.
try:
    person1.name = 'Arlette' # this will raise an error because the person1 frozen data class is immutable  
except AttributeError as e:
    print(e) # this will print the error message to the screen
#So the output of the above code will be:
#cannot assign to field 'name'
#Probably you are going to ask what is the difference between frozen data classes and regular data classes? so let me explain it to you , the main difference between frozen data classes and regular data classes is that frozen data classes are immutable, meaning that their attributes cannot be changed after the object is created, while regular data classes are mutable, meaning that their attributes can be changed. Frozen data classes provide better safety and integrity of data, as they prevent accidental modifications to the object's state. Regular data classes, on the other hand, provide more flexibility and allow for dynamic changes to the object's state.
#Example of a frozen data class:
from dataclasses import dataclass
@dataclass(frozen=True)
class Point:
    x: int
    y: int
point1 = Point(x=10, y=20)
print(point1.x) # this will print the x attribute of the point1 frozen data class to the screen
print(point1.y) # this will print the y attribute of the point1 frozen data class to the screen
#So the output of the above code will be:
#10
#20
#This is an example of a frozen data class because the Point frozen data class is immutable and its attributes cannot be changed after the object is created.
#Example of a regular data class:
from dataclasses import dataclass
@dataclass
class Point:
    x: int
    y: int
point1 = Point(x=10, y=20)
print(point1.x) # this will print the x attribute of the point1 regular data class to the screen
print(point1.y) # this will print the y attribute of the point1 regular data class to the screen
#So the output of the above code will be:
#10
#20

#This is an example of a regular data class because the Point regular data class is mutable and its attributes can be changed after the object is created.

#Probably you are going to ask what is the difference between functions and methods? so let me explain it to you , the main difference between functions and methods is that functions are standalone blocks of code that can be called independently, while methods are functions that are associated with an object and can only be called on that object. Functions are defined using the def keyword, while methods are defined within a class using the def keyword. Functions are used for procedural programming, while methods are used for object-oriented programming.
#Example of a function:
def add(a, b):
    return a + b    
print(add(5, 10)) # this will print the result of the add function to the screen
#So the output of the above code will be:
#15
#This is an example of a function because the add function is a standalone block of code that can be called independently.
#Example of a method:
class Calculator:
    def add(self, a, b):
        return a + b
calc = Calculator() # here we created an object of the Calculator class called calc
print(calc.add(5, 10)) # this will print the result of the add method of the calc object to the screen
#So the output of the above code will be:
#15
#This is an example of a method because the add method is associated with the Calculator object and can only be called on that object.
class Calculator:
    def add(self, a, b):
        return a + b
calc = Calculator() # here we created an object of the Calculator class called calc
print(calc.add(5, 10)) # this will print the result of the add method
#So the output of the above code will be:
#15
#This is an example of a method because the add method is associated with the Calc
#ulator object and can only be called on that object.
#of the calc object to the screen
#So the output of the above code will be:
#15
#of the calc object to the screen
#So the output of the above code will be:
#15

#This is an example of a method because the add method is associated with the Calculator object and can only be called on that object.
#Now that we have practiced different types of variables in Python, you can try to create yourself and explore more about them!
#This is not the end , there is alot more to learn and practice in Python programming! so keep exploring and practicing!And look forward to more advanced topics and concepts in Python programming! 
#I will be here to help you along the way! and update the new knowledge as well!
#My name is Peyman , I am a Python programmer and I love to share my knowledge with others!culator object and can only be called on that object.
